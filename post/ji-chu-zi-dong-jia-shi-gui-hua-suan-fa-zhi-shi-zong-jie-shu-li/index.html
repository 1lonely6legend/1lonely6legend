<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>基础自动驾驶规划算法知识总结梳理 | ogier&#39;s blog</title>
<link rel="shortcut icon" href="https://blog.ogier-maxwell.top/favicon.ico?v=1734325151610">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://blog.ogier-maxwell.top/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="基础自动驾驶规划算法知识总结梳理 | ogier&#39;s blog - Atom Feed" href="https://blog.ogier-maxwell.top/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="search base
三种常见搜索算法的对比

BFS

dijkstra

dijkstra和BFS的区别,就是BFS只能适用于无权图,也就是认为每条路径都是一样的
如果对于一个无权图,使用BFS和Dijkstra是一样的效果
dijk..." />
    <meta name="keywords" content="优化,pnc" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.5.1/build/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://blog.ogier-maxwell.top">
  <img class="avatar" src="https://blog.ogier-maxwell.top/images/avatar.png?v=1734325151610" alt="">
  </a>
  <h1 class="site-title">
    ogier&#39;s blog
  </h1>
  <p class="site-description">
    认识你的美
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              基础自动驾驶规划算法知识总结梳理
            </h2>
            <div class="post-info">
              <span>
                2024-04-19
              </span>
              <span>
                15 min read
              </span>
              
                <a href="https://blog.ogier-maxwell.top/tag/G6tFqzHzG9/" class="post-tag">
                  # 优化
                </a>
              
                <a href="https://blog.ogier-maxwell.top/tag/jx-iYEZEd1/" class="post-tag">
                  # pnc
                </a>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content" v-pre>
                <h1 id="search-base">search base</h1>
<h2 id="三种常见搜索算法的对比">三种常见搜索算法的对比</h2>
<img src="https://raw.githubusercontent.com/1lonely6legend/image-hosting/main/202403271016987.png" alt="image-20240327101612126" style="zoom:33%;" />
<h2 id="bfs">BFS</h2>
<img src="https://raw.githubusercontent.com/1lonely6legend/image-hosting/main/202403271020470.png" alt="image-20240327102000818" style="zoom:33%;" />
<h2 id="dijkstra">dijkstra</h2>
<blockquote>
<p>dijkstra和BFS的区别,就是BFS只能适用于无权图,也就是认为每条路径都是一样的</p>
<p>如果对于一个无权图,使用BFS和Dijkstra是一样的效果</p>
<p>dijkstra等于是引入了一个两点之间移动的权重代价</p>
</blockquote>
<img src="https://raw.githubusercontent.com/1lonely6legend/image-hosting/main/202403271003458.png" alt="image-20240327100350249" style="zoom: 33%;" />
<h2 id="a">a*</h2>
<blockquote>
<p>相比较于dijkstra引入启发式函数，包含距离起始点的距离以及对目标点的距离估计,可以加快搜索时间,启发式函数可以引导搜索过程</p>
</blockquote>
<img src="https://raw.githubusercontent.com/1lonely6legend/image-hosting/main/202403271009092.png" alt="image-20240327100903945" style="zoom:33%;" />
<p>astar常用的启发式函数:</p>
<h4 id="欧几里得距离">欧几里得距离</h4>
<p>就是简单的直线连接距离</p>
<h4 id="曼哈顿距离">曼哈顿距离</h4>
<p>两个点之间xy坐标分别做差之和,就是走直线最短距离</p>
<h3 id="启发式函数设计的原理">启发式函数设计的原理:</h3>
<p><strong>保证启发式函数要小于等于两点之间的真实值,这样才能保证找到最优路径,</strong></p>
<p><strong>当启发式函数等于实际距离值,这样估计很准确,可以做到最优的搜索效率</strong></p>
<p>对于四联通,欧几里得和曼哈顿都可以</p>
<p>对于八联通,曼哈顿不行,因为八联通可以走斜线,不能保证曼哈顿估计的距离小于实际距离</p>
<img src="https://raw.githubusercontent.com/1lonely6legend/image-hosting/main/202403271014062.png" alt="image-20240327101442055" style="zoom:33%;" />
<hr>
<h1 id="sample-base">sample base</h1>
<ol>
<li>在图中生成种子(确定搜索起始点)</li>
<li>使用何种采样方式在图中采样</li>
<li>选择和哪个周围节点进行连接</li>
<li>选择那条边或者删除</li>
</ol>
<h2 id="prm-随机概率路径图">PRM 随机概率路径图</h2>
<blockquote>
<p>优点:</p>
<ol>
<li>具有概率完备性,如果点采的够多,一定可以取到最优路径</li>
</ol>
<p>缺点:</p>
<ol>
<li>PRM是在完整的状态空间中进行采样的,相当于采样版本的dijkstra. 在当我们曲寻找特定初始点与目标点时,会有许多无用的扩展.</li>
<li>并且PRM是直接使用直线来连接采样点,不符合车辆的动力学约束</li>
</ol>
</blockquote>
<blockquote>
<ol>
<li>随机撒点,采样越多,对地图的信息掌握越多(这一步就删除所有碰撞点)</li>
<li>如果中间没有障碍物的话,连接相邻的(一定距离内)节点生成图(删除与障碍物碰撞的连接线)</li>
<li>在图中进行搜索,例如a*,dijkstra</li>
</ol>
</blockquote>
<p>下面sPRM是不剔除边,所有的都连接上</p>
<img src="https://raw.githubusercontent.com/1lonely6legend/image-hosting/main/202403271031641.png" alt="image-20240327103113452" style="zoom:33%;" />
<p>几种改进之后的PRM算法:</p>
<ol>
<li><strong>k-nearest PRM</strong>
<ol>
<li>并不是连接一定距离之内的点,而是连接距离最近的前k个点</li>
</ol>
</li>
<li><strong>Bounded-degree PRM</strong> 有界维度的PRM
<ol>
<li>相当于原始PRM和k-nearest PRM</li>
<li>首先按原始PRM进行取,如果一个节点的一定范围的连接点太多,则使用前k个点连接</li>
</ol>
</li>
<li>Variable-radius PRM 可变半径的PRM
<ol>
<li>把确定周围连接节点距离的半径r,设计成一个与采样点个数n相关的函数</li>
<li>如果采样点越多则减小,采样半径r</li>
</ol>
</li>
</ol>
<h3 id="prm-一种variable-radius-prm-可变半径的prm">PRM* 一种Variable-radius PRM 可变半径的PRM</h3>
<img src="https://raw.githubusercontent.com/1lonely6legend/image-hosting/main/202403271221366.png" alt="image-20240327122131298" style="zoom:33%;" />
<h2 id="rrt-快速生成随机树">RRT 快速生成随机树</h2>
<blockquote>
<p>优点:</p>
<ol>
<li>如果只是需要构建一条起点到终点的路径,相比于PRM,更为高效</li>
</ol>
<p>缺点:</p>
<ol>
<li>不具有概率完备性,只会和距离最近的采样点连接</li>
</ol>
</blockquote>
<img src="https://raw.githubusercontent.com/1lonely6legend/image-hosting/main/202403271226928.png" alt="image-20240327122649902" style="zoom: 25%;" />
<blockquote>
<p>RRT所构建的是一个树,而不是图. 设置搜索起始点作为根节点</p>
<p>这样在只需要寻找两点之间的路径时,相比较于PRM搜索效率高很多</p>
<p>RRT 每次扩展节点时,都试图和目标节点做一次连接测试</p>
</blockquote>
<ol>
<li>首先初始化在RRT中要维护的两个结构,一个时包含顶点的集合V以及包含路径的集合E</li>
<li>开始主循环,设定最大采样次数n次
<ol>
<li>首先进行随机采样,得到X_rand</li>
<li>找到采样点中,距离当前书最近的节点,进行连接</li>
<li>并不是直接连接两点,而是向最近点方向走一个确定的步长</li>
<li>进行一个碰撞检测</li>
<li>判断连接终点是否能连接到树上</li>
</ol>
</li>
</ol>
<img src="https://raw.githubusercontent.com/1lonely6legend/image-hosting/main/202403271228591.png" alt="image-20240327122843623" style="zoom: 50%;" />
<h3 id="rrg-一种具备概率完备性的rrt变体">RRG 一种具备概率完备性的RRT变体</h3>
<p>与RRT的主要不同对应于第九第十行:</p>
<ul>
<li>RRT中直接将最近节点向采样节点进行固定距离延申</li>
<li>RRG改变了连接方式,每次不是直接向采样节点延申,而是考虑以采样点为中心的一个园,将圆内所有节点与采样点的无碰撞路径都进行连接,最终其实构建的是一个图</li>
</ul>
<img src="https://raw.githubusercontent.com/1lonely6legend/image-hosting/main/202403271250120.png" alt="image-20240327125046214" style="zoom:33%;" />
<h3 id="kinematic_based-rrt-一种考虑车辆运动学的rrt">kinematic_based RRT 一种考虑车辆运动学的RRT</h3>
<p>与RRT唯一的区别在于第五行,连接采样点时,基于某种运动学的方法连接(dubin RS曲线等)</p>
<img src="https://raw.githubusercontent.com/1lonely6legend/image-hosting/main/202403271256942.png" alt="image-20240327125610929" style="zoom: 33%;" />
<h2 id="rrt-优化快速随机生成树">RRT* 优化快速随机生成树</h2>
<p>与上面两种方法的对比</p>
<ul>
<li>相比较与RRG,保留了树形的搜索结构,在结构中去掉了冗余的边</li>
<li>相比较与RRT,添加了一个<strong>重构</strong>的过程,确保顶点可以取到最小代价的路径</li>
</ul>
<img src="https://raw.githubusercontent.com/1lonely6legend/image-hosting/main/202403271259308.png" alt="image-20240327125945492" style="zoom:33%;" />
<p>算法整体框架:</p>
<p><img src="https://raw.githubusercontent.com/1lonely6legend/image-hosting/main/202403271911659.png" alt="image-20240327191102984" style="zoom:33%;" />           <img src="https://raw.githubusercontent.com/1lonely6legend/image-hosting/main/202403271918602.png" alt="image-20240327191825262" style="zoom: 50%;" /></p>
<ol>
<li>首先前面部分和普通的RPM一样,采样点,找距离树的最近点,确定最近点X_new</li>
<li>对于最近点利用RRG的特点,连接X_new,半径r内的所有节点</li>
<li>然后遍历半径r内的所有节点,选择cost(距离起点,距离x_new)最小的那个点来连接,这个点为x_min</li>
<li><strong>进行修剪</strong>,遍历x_near(半径r内的点),查看是否可以通过x_new来得到一条剧起点cost更小的节点,如果有,就重新连接</li>
</ol>
<h2 id="cl-rrt-closed-loop-rrt">CL-RRT closed-loop RRT</h2>
<img src="https://raw.githubusercontent.com/1lonely6legend/image-hosting/main/202403271938939.png" alt="image-20240327193801552" style="zoom:50%;" />
<ul>
<li>就是将RRT得到的一个折线结果,当成一个粗解,</li>
<li>然后使用控制器(解耦控制)
<ul>
<li>横向控制器(steer),纯跟踪控制器,输出为方向盘转角序列,也就是给出一条轨迹</li>
</ul>
</li>
<li>根据粗解进行优化,从而进行控制
<ul>
<li>纵向控制器(speed),选择经典的pi控制器,输出速度序列</li>
</ul>
</li>
</ul>
<h3 id="cl_rrt的采样策列">cl_rrt的采样策列</h3>
<p>并不是在空间xy上进行采样,而是在r \theta 空间中进行采样,也就是在一个个同心圆以及不同角度上进行采样,相当于极坐标系采样</p>
<h3 id="cl_rrt最近节点选择策略">cl_rrt最近节点选择策略</h3>
<p>使用dubins曲线来判断最近节点,而不是选择直线最短节点</p>
<h1 id="kinematic-base">kinematic base</h1>
<h2 id="dubins-reeds-shepp曲线作为运动基元">dubins reeds-shepp曲线作为运动基元</h2>
<h3 id="dubins-只有6种组合可能">dubins 只有6种组合可能</h3>
<img src="https://raw.githubusercontent.com/1lonely6legend/image-hosting/main/202403271950472.png" alt="image-20240327195036713" style="zoom:33%;" />
<h3 id="reeds-shepp-48种组合可能">reeds-shepp 48种组合可能</h3>
<img src="C:/Users/ogier/AppData/Roaming/Typora/typora-user-images/image-20240327195119737.png" alt="image-20240327195119737" style="zoom:33%;" />
<h2 id="多项式曲线作为运动基元">多项式曲线作为运动基元</h2>
<h3 id="五次多项式-quintic-polynomial-solver">五次多项式 quintic polynomial solver</h3>
<blockquote>
<p>为什么使用五次多项式: 使用五次多项式对jerk进行优化,五次多项式得到的路径一定是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi><mi>e</mi><mi>r</mi><msup><mi>k</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">jerk^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.008548em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>最小的</p>
</blockquote>
<img src="https://raw.githubusercontent.com/1lonely6legend/image-hosting/main/202403271953587.png" alt="image-20240327195308552" style="zoom:25%;" />
<p>使用初始状态和终点状态,各三个一共六个参数,可以列出六个方程,确定五次多项式函数中的六个参数</p>
<ul>
<li>所以说巡航轨迹规划中,不用考虑末状态的x值,只有五个参数,所以可以使用四次多项式来拟合</li>
</ul>
<h3 id="在st-lt上进行采样">在st lt上进行采样</h3>
<img src="https://raw.githubusercontent.com/1lonely6legend/image-hosting/main/202403271956052.png" alt="image-20240327195627116" style="zoom:25%;" />
<h3 id="在sl-st上进行采样">在sl st上进行采样</h3>
<img src="https://raw.githubusercontent.com/1lonely6legend/image-hosting/main/202403272000485.png" alt="image-20240327200043292" style="zoom: 33%;" />
<h2 id="螺旋曲线作为运动基元spiral-curve">螺旋曲线作为运动基元(spiral Curve)</h2>
<p>确定两个点之间的螺旋曲线,其实是一个BVP问题</p>
<blockquote>
<p>曲率的定义,曲率的定义就是航向角关于弧长的变化率<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>κ</mi><mo>=</mo><mfrac><mrow><mi>d</mi><mi>θ</mi></mrow><mrow><mi>d</mi><mi>s</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\kappa=\frac{d\theta}{ds}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">κ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.2251079999999999em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801079999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight">s</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">d</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">θ</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>,所以曲率关于弧长的积分其实就是航向角的变化</p>
</blockquote>
<ul>
<li>螺旋曲线的定义:一个曲率对弧长的函数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>κ</mi><mo>(</mo><mi>s</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\kappa(s)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">κ</span><span class="mopen">(</span><span class="mord mathdefault">s</span><span class="mclose">)</span></span></span></span>,在每一点的弧长处,我的曲率是多少</li>
<li>**优点:**通过此特性,很容易限制路径曲率的变化</li>
<li>使用三次螺旋曲线来计算<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>κ</mi><mo>(</mo><mi>s</mi><mo>)</mo><mo>=</mo><mi>d</mi><msup><mi>s</mi><mn>3</mn></msup><mo>+</mo><mi>c</mi><msup><mi>s</mi><mn>2</mn></msup><mo>+</mo><mi>b</mi><mi>s</mi><mo>+</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">\kappa(s)=ds^3+cs^2+bs+a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">κ</span><span class="mopen">(</span><span class="mord mathdefault">s</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">d</span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">c</span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span></li>
</ul>
<img src="https://raw.githubusercontent.com/1lonely6legend/image-hosting/main/202403272011439.png" style="zoom: 33%;" />
<h4 id="使用simpson方法求积分">使用simpson方法求积分</h4>
<img src="https://raw.githubusercontent.com/1lonely6legend/image-hosting/main/202403272028684.png" alt="image-20240327202858712" style="zoom:33%;" />
<p>使用一个二次函数来近似原函数的值:</p>
<p>使用近似三个点来拟合出一条二次曲线,然后使用红色曲线积分值来近似蓝色曲线的积分值</p>
<img src="https://raw.githubusercontent.com/1lonely6legend/image-hosting/main/202403272034468.png" alt="image-20240327203433250" style="zoom:33%;" />
<p>具体怎么计算求螺旋曲线参数,还是要看视频啊</p>
<h2 id="混合a">混合a*</h2>
<p>hA*中,在同一个栅格中保存一个最优解</p>
<blockquote>
<p>混合a*一般是找不到最优解,因为有剪枝操作,并且是在控制空间进行采样的,例如只有方向盘转角的最大最小值,0,无法采样到最优的路径</p>
</blockquote>
<img src="https://raw.githubusercontent.com/1lonely6legend/image-hosting/main/202403272046226.png" alt="image-20240327204612127" style="zoom:33%;" />
<img src="https://raw.githubusercontent.com/1lonely6legend/image-hosting/main/202403272047654.png" alt="image-20240327204712381" style="zoom:33%;" />
<h3 id="混合a的两种启发式函数设计">混合a*的两种启发式函数设计</h3>
<h4 id="不考虑障碍物的启发式函数">不考虑障碍物的启发式函数</h4>
<ul>
<li>考虑车辆的运动学约束,不考虑障碍物</li>
<li>使用reeds-shepp曲线长度来作为启发式距离</li>
<li>可以满足启发式距离小于 &lt; 实际距离</li>
</ul>
<h4 id="考虑障碍物的启发式函数">考虑障碍物的启发式函数</h4>
<ul>
<li>忽略车辆的运动学特征,只考虑环境中的障碍物</li>
<li>可以使用简单的a*作为启发式函数</li>
</ul>
<h4 id="同时使用上面两种启发式函数通过调整权重加速搜索">同时使用上面两种启发式函数,通过调整权重,加速搜索</h4>
<h3 id="一种分层规划的思想">一种分层规划的思想</h3>
<ul>
<li>首先使用混合a*来生成一个粗略的解</li>
<li>使用优化的方法在局部进行调整</li>
<li>
<img src="https://raw.githubusercontent.com/1lonely6legend/image-hosting/main/202403272055506.png" alt="image-20240327205508995" style="zoom:25%;" />
</li>
</ul>
<h2 id="state-lattice">State Lattice</h2>
<blockquote>
<p>一种基于逆向运动学的规划方法</p>
</blockquote>
<ol>
<li>首先在fernet坐标系下进行采样
<ul>
<li>在frenet下采样,一般用五次多项式拟合</li>
<li>在cartesian坐标系采样(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo separator="true">,</mo><mi>θ</mi><mo separator="true">,</mo><mi>κ</mi></mrow><annotation encoding="application/x-tex">x,y,\theta,\kappa</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">κ</span></span></span></span>),一般使用三次螺旋曲线</li>
</ul>
</li>
<li>解决BVP问题,使用五次多项式拟合,获得</li>
<li>计算每条路径的cost值</li>
<li>选择最优路径</li>
</ol>
<img src="https://raw.githubusercontent.com/1lonely6legend/image-hosting/main/202403272057541.png" alt="image-20240327205750533" style="zoom:33%;" />
<h3 id="lattice-常用的cost">lattice 常用的cost</h3>
<ul>
<li>safety
<ul>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>J</mi><mrow><mi>s</mi><mi>a</mi><mi>f</mi><mi>e</mi><mi>t</mi><mi>y</mi></mrow></msub><mo>=</mo><mi>c</mi><mi>o</mi><mi>l</mi><mi>l</mi><mi>i</mi><mi>s</mi><mi>i</mi><mi>o</mi><msub><mi>n</mi><mi>c</mi></msub><mi>h</mi><mi>e</mi><mi>c</mi><mi>k</mi><mo>(</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">J_{safety}=collision_check()</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.09618em;">J</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.09618em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">t</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault">o</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">c</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mopen">(</span><span class="mclose">)</span></span></span></span></li>
</ul>
</li>
<li>smoothness
<ul>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>J</mi><mrow><mi>s</mi><mi>m</mi><mi>o</mi><mi>o</mi><mi>t</mi><mi>h</mi></mrow></msub><mo>=</mo><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></msubsup><msubsup><mi>l</mi><mi>i</mi><mrow><mo mathvariant="normal">′</mo><mo mathvariant="normal">′</mo><mo mathvariant="normal">′</mo><mn>2</mn></mrow></msubsup></mrow><annotation encoding="application/x-tex">J_{smooth}=\sum_{i=1}^N{l_i&#x27;&#x27;&#x27;^2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.09618em;">J</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.09618em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">t</span><span class="mord mathdefault mtight">h</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.2809409999999999em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.981231em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-2.441336em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span><span class="mord mtight">′</span><span class="mord mtight">′</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.258664em;"><span></span></span></span></span></span></span></span></span></span></span></li>
</ul>
</li>
<li>centerline attraction
<ul>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>j</mi><mrow><mi>r</mi><mi>e</mi><mi>f</mi></mrow></msub><mo>=</mo><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></msubsup><msubsup><mi>l</mi><mi>i</mi><mn>2</mn></msubsup></mrow><annotation encoding="application/x-tex">j_{ref}=\sum_{i=1}^Nl_i^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9456279999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.05724em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.2809409999999999em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.981231em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-2.441336em;margin-left:-0.01968em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.258664em;"><span></span></span></span></span></span></span></span></span></span></li>
</ul>
</li>
</ul>
<p>final: <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>J</mi><mrow><mi>t</mi><mi>o</mi><mi>t</mi><mi>a</mi><mi>l</mi></mrow></msub><mo>=</mo><msub><mi>w</mi><mn>1</mn></msub><mo>∗</mo><msub><mi>j</mi><mrow><mi>s</mi><mi>a</mi><mi>f</mi><mi>e</mi><mi>t</mi><mi>y</mi></mrow></msub><mo>+</mo><msub><mi>w</mi><mn>2</mn></msub><mo>∗</mo><msub><mi>J</mi><mrow><mi>s</mi><mi>m</mi><mi>o</mi><mi>o</mi><mi>t</mi><mi>h</mi></mrow></msub><mo>+</mo><msub><mi>w</mi><mn>3</mn></msub><mo>∗</mo><msub><mi>J</mi><mrow><mi>r</mi><mi>e</mi><mi>f</mi></mrow></msub></mrow><annotation encoding="application/x-tex">J_{total}=w_1*j_{safety}+w_2*J_{smooth}+w_3*J_{ref}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.09618em;">J</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.09618em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">t</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">t</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.61528em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.9456279999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.05724em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">t</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.61528em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.09618em;">J</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.09618em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">t</span><span class="mord mathdefault mtight">h</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.61528em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.09618em;">J</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.09618em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></p>
<h2 id="正向运动学和逆向运动学方法的对比">正向运动学和逆向运动学方法的对比</h2>
<blockquote>
<p>正向运动学采样:在控制空间进行采样,给定控制量,进行正向推断</p>
<p>逆向运动学采样:在状态空间进行采样,给定初始状态和末状态,推断中间状态</p>
</blockquote>
<img src="https://raw.githubusercontent.com/1lonely6legend/image-hosting/main/202403272108994.png" alt="image-20240327210744195" style="zoom:33%;" />
<h3 id="正向运动学采样-泊车">正向运动学采样-泊车</h3>
<ul>
<li>优点:<strong>易于计算</strong>,给定初始状态量和控制量,整个轨迹都可以根据运动学模型推断出来</li>
<li>缺点:<strong>缺少对于终点的指引</strong>,依赖启发式函数来确定搜索的方向</li>
<li>对环境的探索能力更强</li>
</ul>
<h3 id="逆向运动学采样-结构化道路">逆向运动学采样-结构化道路</h3>
<ul>
<li>优点:强引导性,直接对目标位置进行采样</li>
<li>缺点:难以计算,需要计算一个BVP问题</li>
<li>采样的规则需要小心设定(例如遇到障碍物,采样的范围等)</li>
</ul>
<h1 id="optimizer-base">optimizer base</h1>
<h2 id="数值优化基础">数值优化基础</h2>
<h3 id="优化问题描述">优化问题描述</h3>
<img src="https://raw.githubusercontent.com/1lonely6legend/image-hosting/main/2024/03/28/20240328123759.png" alt="image-20240328123758079" style="zoom:33%;" />
<ul>
<li>
<p>目的：为了最小化一个函数，称为object/cost function</p>
</li>
<li>
<p>X为一个优化变量/向量，多个变量</p>
</li>
<li>
<p>s为x的取值范围，称为一个feasible region，一般会对约束进行拆分</p>
<ul>
<li>等式约束</li>
<li>不等式约束</li>
</ul>
</li>
</ul>
<h3 id="局部最优和全局最优">局部最优和全局最优：</h3>
<img src="https://raw.githubusercontent.com/1lonely6legend/image-hosting/main/2024/03/28/20240328125217.png" alt="image-20240328125216708" style="zoom:33%;" />
<ul>
<li>强局部最优，必须要小于周围值</li>
<li>弱局部最优，小于等于局部值</li>
</ul>
<h3 id="无约束优化关键是如何选择迭代下降方向">无约束优化（关键是如何选择迭代下降方向）</h3>
<blockquote>
<p>对于无约束问题,我们最小化函数只取决于优化变量,并且优化变量无限制</p>
<p>对于一个无约束问题:解是局部最优解的一个必要条件为,当前解的梯度为0</p>
</blockquote>
<p>常见的无约束问题求解方法:</p>
<blockquote>
<p><strong>梯度下降-1阶</strong>雅可比矩阵：下降方向为梯度反方向， 下降步长由线性搜索确定</p>
<p>​	在远离极小值的位置下降跟快，在极小值附近下降很慢</p>
<p><strong>高斯法-2阶</strong>黑塞矩阵： 下降方向由逼近的二次函数确定，下降步长由线性搜索确定/或者直接使用二次函数最小值。实际上是对目标函数F二次偏导的迭代</p>
<p>​	高司法在二阶导数的意义下，从函数凸性考虑，相当于不仅考虑坡度，还会考虑坡度的变化量</p>
<p><strong>高斯牛顿法-1阶</strong>使用两个雅可比矩阵来近似黑塞矩阵：将原问题考虑为最小二乘法之后，也采用一阶导。</p>
<p>​	高斯牛顿为分解目标函数F为f*f后，对f的一次偏导的迭代。</p>
<p>​	其利用了目标函数的泰勒展开式把非线性函数的最小二乘化问题化为每次迭代的线性函数的最小二乘化问题。</p>
<p>​	缺点就是若初始点距离极小值点过远，迭代步长过大会导致迭代下一代的函数值不一定小于上一代的函数值。</p>
<p>Levenberg-Marquart:</p>
<p>​	当μ大时相当于梯度下降法，μ小时相当于高斯牛顿法。</p>
<p>​	设置一个比较小的μ值，当发现目标函数反而增大时，将μ增大使用梯度下降法快速寻找，然后再将μ减小使用牛顿法进行寻找。</p>
</blockquote>
<ul>
<li>
<h4 id="梯度下降法1阶-是指只用到了梯度">梯度下降法(1阶-是指只用到了梯度)</h4>
<ul>
<li>
<img src="https://raw.githubusercontent.com/1lonely6legend/image-hosting/main/2024/03/28/20240328131711.png" alt="image-20240328131709740" style="zoom:33%;" />
</li>
<li>
<img src="https://raw.githubusercontent.com/1lonely6legend/image-hosting/main/2024/03/28/20240328130133.png" alt="image-20240328130132163" style="zoom:33%;" />
</li>
<li>在每一迭代中,第k+1次迭代值为上一步向梯度反方向增加固定值<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>x</mi><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msup><mo>=</mo><msup><mi>x</mi><mi>k</mi></msup><mo>+</mo><msup><mi>α</mi><mi>k</mi></msup><mo>⋅</mo><mi mathvariant="normal">Δ</mi><msup><mi>x</mi><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">x^{k+1}=x^k+\alpha^k\cdot\Delta x^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8491079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8491079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.932438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord">Δ</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span>,</li>
<li>梯度下降法的收敛条件，工程上，可能要求多个条件都满足时，停止优化
<ul>
<li>相邻两次下降优化变量x差值很小</li>
<li>相邻两次优化变量差值与上次优化变量的比值很小</li>
<li>相邻两次cost函数值差距很小，cost几乎不下降了</li>
</ul>
</li>
<li><strong>线性搜索确定每一次的下降步长</strong>
<ul>
<li><img src="https://raw.githubusercontent.com/1lonely6legend/image-hosting/main/2024/03/28/20240328130652.png" alt="image-20240328130650429" style="zoom:33%;" />（P_k代表当前找到的搜索方向）</li>
<li>精确线性搜索，不常用
<ul>
<li>在下降方向上（一个切面上），找到cost最小值，不一定是全局最优解，只是这个下降方向就不一定对</li>
</ul>
</li>
<li>非精确的线性搜索，常用
<ul>
<li>不要求找到最小的cost点，见上面的图，只要在这个方向上，cost下降到一定水平，就可以</li>
</ul>
</li>
<li>回溯的线性搜索
<ul>
<li><img src="https://raw.githubusercontent.com/1lonely6legend/image-hosting/main/2024/03/28/20240328131018.png" alt="image-20240328131017478" style="zoom:25%;" />（纵轴为cost值，这个图和上面的一样含义，只是换了个标志）</li>
<li>在当前位置找切线，只要当前确定的步长在上图的两个虚线之间，都是可以的</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<h4 id="牛顿法2阶使用二次函数逼近原函数">牛顿法(2阶)使用二次函数逼近原函数</h4>
<ul>
<li><img src="https://raw.githubusercontent.com/1lonely6legend/image-hosting/main/2024/03/28/20240328131840.png" alt="image-20240328131838703" style="zoom:33%;" /><img src="https://raw.githubusercontent.com/1lonely6legend/image-hosting/main/2024/03/28/20240328132321.png" alt="image-20240328132319190" style="zoom: 33%;" /></li>
<li>当前点做一个二阶泰勒展开，提取相邻曲线的信息</li>
<li>通过泰勒展开，利用逼近的二次函数下降方向，作为原函数的下降方向，</li>
<li>下降方向<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>δ</mi><mo>=</mo><mo>−</mo><msup><mi>H</mi><mrow><mo>−</mo><mn>1</mn></mrow></msup><mo>⋅</mo><mi mathvariant="normal">∇</mi><mi>f</mi><mo>(</mo><mi>x</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">\delta=-H^{-1}\cdot\nabla f(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03785em;">δ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∇</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span>,下降方式为-黑塞矩阵逆乘以梯度</li>
</ul>
</li>
<li>
<h4 id="高斯牛顿法2阶面向最小二乘的类型很多函数的平方和的最小值">高斯牛顿法(2阶)，面向最小二乘的类型，很多函数的平方和的最小值</h4>
<ul>
<li>
<img src="https://raw.githubusercontent.com/1lonely6legend/image-hosting/main/2024/03/28/20240328132718.png" alt="image-20240328132716900" style="zoom:33%;" />
</li>
<li></li>
</ul>
</li>
<li>
<h4 id="levenberg-marquardt列文伯格-马夸尔特-lm算法">levenberg-Marquardt（列文伯格-马夸尔特）-LM算法</h4>
<ul>
<li>当μ大时相当于梯度下降法，μ小时相当于高斯牛顿法。</li>
<li>设置一个比较小的μ值，当发现目标函数反而增大时，将μ增大使用梯度下降法快速寻找，然后再将μ减小使用牛顿法进行寻找。</li>
</ul>
</li>
</ul>
<h3 id="二次规划">二次规划</h3>
<p>凸优化问题的描述：</p>
<img src="https://raw.githubusercontent.com/1lonely6legend/image-hosting/main/2024/03/28/20240328142908.png" alt="image-20240328142907074" style="zoom:33%;" />
<p>对于一个优化函数，本事是凸函数，并且不等式函数约束也为凸函数，还有线性的等式约束，这就可以成为一个凸优化问题。</p>
<img src="https://raw.githubusercontent.com/1lonely6legend/image-hosting/main/2024/03/28/20240328143250.png" alt="image-20240328143248183" style="zoom:33%;" />
<h4 id="二次规划qp定义">二次规划QP定义：</h4>
<img src="https://raw.githubusercontent.com/1lonely6legend/image-hosting/main/2024/03/28/20240328143339.png" alt="image-20240328143338426" style="zoom:33%;" />
<ul>
<li>cost function转为一个二次型表示]</li>
<li>所有的约束都要是线性的（包含等式和不等式约束）</li>
</ul>
<blockquote>
<p>osqp求解器中，没有单独的等式约束，等式表示为a≤x≤a</p>
<img src="https://raw.githubusercontent.com/1lonely6legend/image-hosting/main/2024/03/28/20240328143815.png" alt="image-20240328143814018" style="zoom:33%;" />
<p>在osqp求解的矩阵输入中，稀疏矩阵P A需要表示为csc矩阵，压缩空间</p>
<p><a href="https://zhuanlan.zhihu.com/p/557231877">高性能稀疏矩阵乘法（coo，csr，csc）</a></p>
</blockquote>
<h3 id="非凸优化问题">非凸优化问题</h3>
<img src="https://raw.githubusercontent.com/1lonely6legend/image-hosting/main/2024/03/28/20240328144141.png" alt="image-20240328144140260" style="zoom:33%;" />
<p>常用的求解方式：</p>
<ul>
<li>SQP 拆解为多个QP问题</li>
<li>IPM 内点可行域迭代</li>
</ul>
<blockquote>
<p>常用的非线性求解器Ipopt，使用内点法来求解</p>
</blockquote>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li><a href="#search-base">search base</a>
<ul>
<li><a href="#%E4%B8%89%E7%A7%8D%E5%B8%B8%E8%A7%81%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E7%9A%84%E5%AF%B9%E6%AF%94">三种常见搜索算法的对比</a></li>
<li><a href="#bfs">BFS</a></li>
<li><a href="#dijkstra">dijkstra</a></li>
<li><a href="#a">a*</a><br>
*
<ul>
<li><a href="#%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E8%B7%9D%E7%A6%BB">欧几里得距离</a></li>
<li><a href="#%E6%9B%BC%E5%93%88%E9%A1%BF%E8%B7%9D%E7%A6%BB">曼哈顿距离</a></li>
<li><a href="#%E5%90%AF%E5%8F%91%E5%BC%8F%E5%87%BD%E6%95%B0%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%8E%9F%E7%90%86">启发式函数设计的原理:</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sample-base">sample base</a>
<ul>
<li><a href="#prm-%E9%9A%8F%E6%9C%BA%E6%A6%82%E7%8E%87%E8%B7%AF%E5%BE%84%E5%9B%BE">PRM 随机概率路径图</a>
<ul>
<li><a href="#prm-%E4%B8%80%E7%A7%8Dvariable-radius-prm-%E5%8F%AF%E5%8F%98%E5%8D%8A%E5%BE%84%E7%9A%84prm">PRM* 一种Variable-radius PRM 可变半径的PRM</a></li>
</ul>
</li>
<li><a href="#rrt-%E5%BF%AB%E9%80%9F%E7%94%9F%E6%88%90%E9%9A%8F%E6%9C%BA%E6%A0%91">RRT 快速生成随机树</a>
<ul>
<li><a href="#rrg-%E4%B8%80%E7%A7%8D%E5%85%B7%E5%A4%87%E6%A6%82%E7%8E%87%E5%AE%8C%E5%A4%87%E6%80%A7%E7%9A%84rrt%E5%8F%98%E4%BD%93">RRG 一种具备概率完备性的RRT变体</a></li>
<li><a href="#kinematic_based-rrt-%E4%B8%80%E7%A7%8D%E8%80%83%E8%99%91%E8%BD%A6%E8%BE%86%E8%BF%90%E5%8A%A8%E5%AD%A6%E7%9A%84rrt">kinematic_based RRT 一种考虑车辆运动学的RRT</a></li>
</ul>
</li>
<li><a href="#rrt-%E4%BC%98%E5%8C%96%E5%BF%AB%E9%80%9F%E9%9A%8F%E6%9C%BA%E7%94%9F%E6%88%90%E6%A0%91">RRT* 优化快速随机生成树</a></li>
<li><a href="#cl-rrt-closed-loop-rrt">CL-RRT closed-loop RRT</a>
<ul>
<li><a href="#cl_rrt%E7%9A%84%E9%87%87%E6%A0%B7%E7%AD%96%E5%88%97">cl_rrt的采样策列</a></li>
<li><a href="#cl_rrt%E6%9C%80%E8%BF%91%E8%8A%82%E7%82%B9%E9%80%89%E6%8B%A9%E7%AD%96%E7%95%A5">cl_rrt最近节点选择策略</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#kinematic-base">kinematic base</a>
<ul>
<li><a href="#dubins-reeds-shepp%E6%9B%B2%E7%BA%BF%E4%BD%9C%E4%B8%BA%E8%BF%90%E5%8A%A8%E5%9F%BA%E5%85%83">dubins reeds-shepp曲线作为运动基元</a>
<ul>
<li><a href="#dubins-%E5%8F%AA%E6%9C%896%E7%A7%8D%E7%BB%84%E5%90%88%E5%8F%AF%E8%83%BD">dubins 只有6种组合可能</a></li>
<li><a href="#reeds-shepp-48%E7%A7%8D%E7%BB%84%E5%90%88%E5%8F%AF%E8%83%BD">reeds-shepp 48种组合可能</a></li>
</ul>
</li>
<li><a href="#%E5%A4%9A%E9%A1%B9%E5%BC%8F%E6%9B%B2%E7%BA%BF%E4%BD%9C%E4%B8%BA%E8%BF%90%E5%8A%A8%E5%9F%BA%E5%85%83">多项式曲线作为运动基元</a>
<ul>
<li><a href="#%E4%BA%94%E6%AC%A1%E5%A4%9A%E9%A1%B9%E5%BC%8F-quintic-polynomial-solver">五次多项式 quintic polynomial solver</a></li>
<li><a href="#%E5%9C%A8st-lt%E4%B8%8A%E8%BF%9B%E8%A1%8C%E9%87%87%E6%A0%B7">在st lt上进行采样</a></li>
<li><a href="#%E5%9C%A8sl-st%E4%B8%8A%E8%BF%9B%E8%A1%8C%E9%87%87%E6%A0%B7">在sl st上进行采样</a></li>
</ul>
</li>
<li><a href="#%E8%9E%BA%E6%97%8B%E6%9B%B2%E7%BA%BF%E4%BD%9C%E4%B8%BA%E8%BF%90%E5%8A%A8%E5%9F%BA%E5%85%83spiral-curve">螺旋曲线作为运动基元(spiral Curve)</a><br>
*
<ul>
<li><a href="#%E4%BD%BF%E7%94%A8simpson%E6%96%B9%E6%B3%95%E6%B1%82%E7%A7%AF%E5%88%86">使用simpson方法求积分</a></li>
</ul>
</li>
<li><a href="#%E6%B7%B7%E5%90%88a">混合a*</a>
<ul>
<li><a href="#%E6%B7%B7%E5%90%88a%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%90%AF%E5%8F%91%E5%BC%8F%E5%87%BD%E6%95%B0%E8%AE%BE%E8%AE%A1">混合a*的两种启发式函数设计</a>
<ul>
<li><a href="#%E4%B8%8D%E8%80%83%E8%99%91%E9%9A%9C%E7%A2%8D%E7%89%A9%E7%9A%84%E5%90%AF%E5%8F%91%E5%BC%8F%E5%87%BD%E6%95%B0">不考虑障碍物的启发式函数</a></li>
<li><a href="#%E8%80%83%E8%99%91%E9%9A%9C%E7%A2%8D%E7%89%A9%E7%9A%84%E5%90%AF%E5%8F%91%E5%BC%8F%E5%87%BD%E6%95%B0">考虑障碍物的启发式函数</a></li>
<li><a href="#%E5%90%8C%E6%97%B6%E4%BD%BF%E7%94%A8%E4%B8%8A%E9%9D%A2%E4%B8%A4%E7%A7%8D%E5%90%AF%E5%8F%91%E5%BC%8F%E5%87%BD%E6%95%B0%E9%80%9A%E8%BF%87%E8%B0%83%E6%95%B4%E6%9D%83%E9%87%8D%E5%8A%A0%E9%80%9F%E6%90%9C%E7%B4%A2">同时使用上面两种启发式函数,通过调整权重,加速搜索</a></li>
</ul>
</li>
<li><a href="#%E4%B8%80%E7%A7%8D%E5%88%86%E5%B1%82%E8%A7%84%E5%88%92%E7%9A%84%E6%80%9D%E6%83%B3">一种分层规划的思想</a></li>
</ul>
</li>
<li><a href="#state-lattice">State Lattice</a>
<ul>
<li><a href="#lattice-%E5%B8%B8%E7%94%A8%E7%9A%84cost">lattice 常用的cost</a></li>
</ul>
</li>
<li><a href="#%E6%AD%A3%E5%90%91%E8%BF%90%E5%8A%A8%E5%AD%A6%E5%92%8C%E9%80%86%E5%90%91%E8%BF%90%E5%8A%A8%E5%AD%A6%E6%96%B9%E6%B3%95%E7%9A%84%E5%AF%B9%E6%AF%94">正向运动学和逆向运动学方法的对比</a>
<ul>
<li><a href="#%E6%AD%A3%E5%90%91%E8%BF%90%E5%8A%A8%E5%AD%A6%E9%87%87%E6%A0%B7-%E6%B3%8A%E8%BD%A6">正向运动学采样-泊车</a></li>
<li><a href="#%E9%80%86%E5%90%91%E8%BF%90%E5%8A%A8%E5%AD%A6%E9%87%87%E6%A0%B7-%E7%BB%93%E6%9E%84%E5%8C%96%E9%81%93%E8%B7%AF">逆向运动学采样-结构化道路</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#optimizer-base">optimizer base</a>
<ul>
<li><a href="#%E6%95%B0%E5%80%BC%E4%BC%98%E5%8C%96%E5%9F%BA%E7%A1%80">数值优化基础</a>
<ul>
<li><a href="#%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0">优化问题描述</a></li>
<li><a href="#%E5%B1%80%E9%83%A8%E6%9C%80%E4%BC%98%E5%92%8C%E5%85%A8%E5%B1%80%E6%9C%80%E4%BC%98">局部最优和全局最优：</a></li>
<li><a href="#%E6%97%A0%E7%BA%A6%E6%9D%9F%E4%BC%98%E5%8C%96%E5%85%B3%E9%94%AE%E6%98%AF%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E8%BF%AD%E4%BB%A3%E4%B8%8B%E9%99%8D%E6%96%B9%E5%90%91">无约束优化（关键是如何选择迭代下降方向）</a>
<ul>
<li><a href="#%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E6%B3%951%E9%98%B6-%E6%98%AF%E6%8C%87%E5%8F%AA%E7%94%A8%E5%88%B0%E4%BA%86%E6%A2%AF%E5%BA%A6">梯度下降法(1阶-是指只用到了梯度)</a></li>
<li><a href="#%E7%89%9B%E9%A1%BF%E6%B3%952%E9%98%B6%E4%BD%BF%E7%94%A8%E4%BA%8C%E6%AC%A1%E5%87%BD%E6%95%B0%E9%80%BC%E8%BF%91%E5%8E%9F%E5%87%BD%E6%95%B0">牛顿法(2阶)使用二次函数逼近原函数</a></li>
<li><a href="#%E9%AB%98%E6%96%AF%E7%89%9B%E9%A1%BF%E6%B3%952%E9%98%B6%E9%9D%A2%E5%90%91%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%BE%88%E5%A4%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%B9%B3%E6%96%B9%E5%92%8C%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC">高斯牛顿法(2阶)，面向最小二乘的类型，很多函数的平方和的最小值</a></li>
<li><a href="#levenberg-marquardt%E5%88%97%E6%96%87%E4%BC%AF%E6%A0%BC-%E9%A9%AC%E5%A4%B8%E5%B0%94%E7%89%B9-lm%E7%AE%97%E6%B3%95">levenberg-Marquardt（列文伯格-马夸尔特）-LM算法</a></li>
</ul>
</li>
<li><a href="#%E4%BA%8C%E6%AC%A1%E8%A7%84%E5%88%92">二次规划</a>
<ul>
<li><a href="#%E4%BA%8C%E6%AC%A1%E8%A7%84%E5%88%92qp%E5%AE%9A%E4%B9%89">二次规划QP定义：</a></li>
</ul>
</li>
<li><a href="#%E9%9D%9E%E5%87%B8%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98">非凸优化问题</a></li>
</ul>
</li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://blog.ogier-maxwell.top/post/gou-zao-han-shu-lie-biao-chu-shi-hua-yu-fu-zhi/">
              <h3 class="post-title">
                构造函数列表初始化与赋值
              </h3>
            </a>
          </div>
        

        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">抛瓦</a>
  <a class="rss" href="https://blog.ogier-maxwell.top/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
